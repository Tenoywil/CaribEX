# CaribX Architecture Guide

## Overview

CaribX is a Next.js 15 application built with TypeScript, Redux Toolkit, and Redux-Saga. This document provides a detailed overview of the application architecture, design patterns, and technical decisions.

---

## Technology Stack

### Core Framework
- **Next.js 15**: React framework with App Router for server-side rendering and optimal performance
- **TypeScript**: Type-safe JavaScript for better developer experience and code quality
- **React 18**: Modern React with concurrent features and improved performance

### State Management
- **Redux Toolkit**: Simplified Redux with less boilerplate
- **Redux-Saga**: Side effects management for complex async flows
- **Reselect**: Memoized selectors for optimized performance

### Styling
- **Tailwind CSS**: Utility-first CSS framework for rapid UI development
- **PostCSS**: CSS processing and optimization

### Testing
- **Jest**: Unit testing framework
- **React Testing Library**: Component testing
- **Redux-Saga-Test-Plan**: Saga testing utilities
- **Playwright**: End-to-end testing

### API & Data
- **Axios**: HTTP client for API requests
- **SWR**: Stale-while-revalidate data fetching pattern
- **Ethers.js**: Ethereum blockchain interaction
- **Wagmi**: React hooks for Ethereum

---

## Architecture Layers

### 1. Presentation Layer (Components)

Components are organized by feature and responsibility:

```
/components
  /ui          - Reusable UI primitives (buttons, inputs, loaders)
  /layout      - Layout components (header, footer, navigation)
  /marketplace - Marketplace-specific components
  /wallet      - Wallet operations components
  /cart        - Shopping cart components
```

**Design Principles:**
- Components are small, focused, and reusable
- Props are strictly typed with TypeScript interfaces
- Business logic is kept in hooks and Redux
- Components handle presentation only

### 2. State Management Layer (Redux)

State is organized by domain with clear separation of concerns:

```
/redux
  store.ts           - Store configuration
  /reducers         - State updates (pure functions)
  /selectors        - Data queries (memoized)
  /sagas            - Side effects (async operations)
  /actions          - Action creators (auto-generated by RTK)
```

**State Shape:**
```typescript
{
  auth: {
    user: User | null,
    session: Session | null,
    isAuthenticated: boolean,
    loading: boolean,
    error: string | null
  },
  products: {
    byId: Record<string, Product>,
    allIds: string[],
    listMeta: { page, total, perPage },
    loading: boolean,
    error: string | null
  },
  cart: {
    id: string | null,
    items: CartItem[],
    total: number,
    loading: boolean,
    error: string | null
  },
  wallet: {
    balance: number,
    currency: string,
    transactions: Transaction[],
    loading: boolean,
    error: string | null
  }
}
```

### 3. Business Logic Layer (Sagas)

Sagas handle complex async workflows:

**Example: Send Funds Flow**
```
1. User dispatches SEND_FUNDS_REQUEST
2. walletSaga creates pending transaction via API
3. Saga triggers wallet signature (if needed)
4. Saga submits signed transaction
5. Saga waits for confirmation
6. Saga dispatches SEND_FUNDS_SUCCESS or FAILURE
7. UI updates automatically via Redux
```

### 4. Data Layer (API Client & Cache)

**API Client:**
- Centralized HTTP client with interceptors
- Automatic error handling
- Cookie-based authentication
- Request/response transformations

**Caching Strategy:**
- **L1 (Client)**: In-memory Map with TTL
- **L2 (Backend)**: Redis cache on server
- SWR pattern: show stale data, revalidate in background

---

## Design Patterns

### 1. Container/Presentation Pattern
- Smart components (containers) connect to Redux
- Presentational components receive data via props
- Clear separation of concerns

### 2. Normalized State
- Entities stored as `{ byId, allIds }`
- Prevents duplication and inconsistencies
- Efficient updates and lookups

### 3. Optimistic Updates
- UI updates immediately on user action
- Revert on API failure
- Better perceived performance

### 4. Circuit Breaker Pattern
- Protects against cascading failures
- Stops requests to failing services
- Automatic recovery attempts

### 5. Event-Driven Architecture
- Actions represent events, not commands
- Sagas listen to actions and trigger side effects
- Decoupled components communicate via Redux

---

## Data Flow

### Read Operations (Query)
```
Component → Selector → Redux State → Render
                ↓
            Cache Check
                ↓
          API Call (if needed)
                ↓
            Redux Update
```

### Write Operations (Mutation)
```
Component → Action → Saga → API → Success/Failure
                                        ↓
                                  Redux Update
                                        ↓
                                  Cache Invalidation
                                        ↓
                                  UI Refresh
```

---

## Security Considerations

### Authentication
- SIWE (Sign-In With Ethereum) for wallet-based auth
- Nonce rotation to prevent replay attacks
- HTTP-only cookies prevent XSS theft
- Secure, SameSite=Strict for CSRF protection

### Data Protection
- Never store private keys in browser
- Sanitize all user inputs
- Validate data on both client and server
- Minimal PII exposure in UI

### API Security
- HTTPS only in production
- CORS configuration for allowed origins
- Rate limiting on sensitive endpoints
- JWT or session-based authentication

---

## Performance Optimizations

### 1. Code Splitting
- Automatic route-based splitting via Next.js
- Dynamic imports for heavy components
- Smaller initial bundle size

### 2. Caching
- Two-level cache (client + server)
- Aggressive TTL for static data
- Cache invalidation on mutations

### 3. Memoization
- Reselect for expensive selector computations
- React.memo for component re-renders
- useMemo/useCallback hooks

### 4. Image Optimization
- Next.js Image component for automatic optimization
- Lazy loading for off-screen images
- WebP format with fallbacks

---

## Error Handling

### Levels of Error Handling

1. **Component Level**: Try-catch for local errors
2. **Redux Level**: Error states in reducers
3. **Saga Level**: Error boundaries and fallbacks
4. **API Level**: Interceptors for common errors
5. **Global Level**: Error boundary components

### Error Recovery Strategies

- **Retry Logic**: Automatic retries for transient failures
- **Circuit Breaker**: Stop requests to failing services
- **Graceful Degradation**: Show cached data when API fails
- **User Feedback**: Clear error messages and recovery actions

---

## Testing Strategy

### Unit Tests
- All reducers (pure functions)
- All selectors (memoization)
- Utility functions
- Custom hooks

### Integration Tests
- Sagas with mock API
- Component + Redux integration
- Hook + Redux integration

### E2E Tests
- Critical user flows
- Wallet connection
- Send/receive funds
- Marketplace browsing
- Checkout process

---

## Scalability Considerations

### State Management
- Normalized state prevents duplication
- Selectors prevent unnecessary re-renders
- Sagas can be split for parallel processing

### API Calls
- Request batching where possible
- Pagination for large datasets
- Infinite scroll for better UX

### Bundle Size
- Tree shaking to remove unused code
- Dynamic imports for route-based splitting
- Compression (gzip/brotli)

---

## Future Enhancements

- [ ] Offline support with service workers
- [ ] Real-time updates via WebSockets
- [ ] Progressive Web App (PWA) features
- [ ] Advanced caching with IndexedDB
- [ ] Multi-language support (i18n)
- [ ] Advanced analytics and monitoring
- [ ] A/B testing framework
- [ ] GraphQL API integration option

---

## Conclusion

This architecture provides a solid foundation for a production-ready application with excellent performance, maintainability, and scalability. The clear separation of concerns and use of established patterns make it easy to reason about and extend.
